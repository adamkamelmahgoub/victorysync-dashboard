import fetch from 'node-fetch';
import { MIGHTYCALL_API_KEY, MIGHTYCALL_USER_KEY, MIGHTYCALL_BASE_URL } from '../config/env';

// Retry helper
async function delay(ms: number) { return new Promise((r) => setTimeout(r, ms)); }
async function requestWithRetry(url: string, opts: any, retries = 2, backoff = 250) {
  let attempt = 0;
  while (true) {
    attempt += 1;
    try {
      return await fetch(url, opts);
    } catch (e: any) {
      if (attempt > retries) throw e;
      await delay(backoff * attempt);
    }
  }
}

function buildUrlVariants(base: string, endpoint: string) {
  const b = (base || '').replace(/\/$/, '');
  const ep = endpoint || '';
  return [`${b}${ep}`, `${b}/api${ep}`];
}

export async function getMightyCallAccessToken(override?: { clientId?: string; clientSecret?: string }): Promise<string> {
  const base = (MIGHTYCALL_BASE_URL || '').replace(/\/$/, '');
  const clientId = override?.clientId || MIGHTYCALL_API_KEY || '';
  const clientSecret = override?.clientSecret || MIGHTYCALL_USER_KEY || '';
  const candidates = buildUrlVariants(base, '/auth/token');

  for (const url of candidates) {
    try {
      const body = new URLSearchParams();
      body.append('grant_type', 'client_credentials');
      body.append('client_id', clientId);
      body.append('client_secret', clientSecret);
      const res = await requestWithRetry(url, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded', 'x-api-key': MIGHTYCALL_API_KEY || '' }, body: body.toString() }, 2, 300);
      const text = await res.text().catch(() => '');
      if (!res.ok) continue;
      try {
        const j = JSON.parse(text || '{}');
        const token = j?.access_token || j?.token || null;
        if (token) return token;
      } catch (e) { continue; }
    } catch (e) { continue; }
  }
  throw new Error('Failed to obtain MightyCall access token');
}

async function tryFetchJson(url: string, token?: string) {
  const res = await requestWithRetry(url, { method: 'GET', headers: { Accept: 'application/json', 'x-api-key': MIGHTYCALL_API_KEY || '', ...(token ? { Authorization: `Bearer ${token}` } : {}) } }, 2, 300);
  const text = await res.text().catch(() => '');
  if (!res.ok) return { ok: false, status: res.status, body: text };
  try { return { ok: true, status: res.status, body: JSON.parse(text || 'null') }; } catch (e) { return { ok: true, status: res.status, body: text }; }
}

export async function fetchMightyCallPhoneNumbers(accessToken: string) {
  const base = (MIGHTYCALL_BASE_URL || '').replace(/\/$/, '');
  const endpoints = ['/phonenumbers', '/phone_numbers', '/v4/phonenumbers', '/v4/phone_numbers'];
  for (const ep of endpoints) {
    for (const url of buildUrlVariants(base, ep)) {
      const r = await tryFetchJson(url, accessToken);
      if (r.ok && r.body) {
        const list = r.body?.data?.phoneNumbers ?? r.body?.phoneNumbers ?? r.body?.data ?? [];
        if (Array.isArray(list)) return list;
      }
    }
  }
  return [];
}

export async function fetchMightyCallCalls(accessToken: string, filters?: any) {
  const base = (MIGHTYCALL_BASE_URL || '').replace(/\/$/, '');
  const endpoints = ['/calls', '/api/calls', '/v4/calls', '/api/calls/list'];
  for (const ep of endpoints) {
    for (const url of buildUrlVariants(base, ep)) {
      try {
        const params = new URLSearchParams();
        if (filters?.startUtc) params.append('startUtc', filters.startUtc);
        if (filters?.endUtc) params.append('endUtc', filters.endUtc);
        if (filters?.dateStart) params.append('dateStart', filters.dateStart);
        if (filters?.dateEnd) params.append('dateEnd', filters.dateEnd);
        if (filters?.pageSize) params.append('pageSize', String(filters.pageSize));
        if (filters?.skip) params.append('skip', String(filters.skip));
        const full = params.toString() ? `${url}?${params.toString()}` : url;
        const r = await tryFetchJson(full, accessToken);
        if (r.ok && r.body) {
          const list = r.body?.data?.calls ?? r.body?.calls ?? r.body?.data ?? r.body ?? [];
          if (Array.isArray(list)) return list;
        }
      } catch (e) { continue; }
    }
  }
  return [];
}

export async function fetchMightyCallJournalRequests(accessToken: string, params: Record<string,string>) {
  const base = (MIGHTYCALL_BASE_URL || '').replace(/\/$/, '');
  const ep = '/journal/requests';
  for (const url of buildUrlVariants(base, ep)) {
    const full = `${url}?${new URLSearchParams(params).toString()}`;
    const r = await tryFetchJson(full, accessToken);
    if (r.ok && r.body) {
      const list = r.body?.requests ?? r.body?.data?.requests ?? [];
      if (Array.isArray(list)) return list;
    }
  }
  return [];
}

export async function fetchMightyCallRecordings(accessToken: string, phoneNumberIds: string[], startDate: string, endDate: string) {
  // Prefer calls endpoint
  const calls = await fetchMightyCallCalls(accessToken, { startUtc: startDate, endUtc: endDate, pageSize: '1000', skip: '0' });
  const recordings: any[] = [];
  for (const c of calls) {
    const rec = c?.callRecord ?? c?.recording ?? null;
    if (rec && (rec.uri || rec.fileName || rec.link)) recordings.push({ id: c.id, callId: c.id, recordingUrl: rec.uri || rec.fileName || rec.link, duration: c.duration ?? null, date: c.dateTimeUtc ?? c.created ?? null, metadata: c });
  }
  if (recordings.length > 0) return recordings;

  // journal fallback
  const jr = await fetchMightyCallJournalRequests(accessToken, { from: `${startDate}T00:00:00Z`, to: `${endDate}T23:59:59Z`, type: 'Call', pageSize: '1000', page: '1' });
  for (const r of jr) {
    const link = r?.recording?.link ?? r?.recording?.uri ?? r?.textModel?.text ?? null;
    if (link) recordings.push({ id: r.id, callId: r.id, recordingUrl: link, duration: null, date: r.created ?? null, metadata: r });
  }
  return recordings;
}

export async function fetchMightyCallSMS(accessToken?: string) {
  const token = accessToken || await getMightyCallAccessToken();
  const list = await fetchMightyCallJournalRequests(token, { pageSize: '1000', page: '1', type: 'Message' });
  return Array.isArray(list) ? list : [];
}

// Sync functions used by scripts
export async function syncMightyCallReports(supabaseAdminClient: any, orgId: string, phoneNumberIds: string[], startDate: string, endDate: string, overrideCreds?: { clientId?: string; clientSecret?: string }) {
  const token = await getMightyCallAccessToken(overrideCreds);
  const reports = await fetchMightyCallJournalRequests(token, { from: `${startDate}T00:00:00Z`, to: `${endDate}T23:59:59Z`, type: 'Call', pageSize: '1000', page: '1' });
  const recordings = await fetchMightyCallRecordings(token, phoneNumberIds, startDate, endDate);

  let reportsSynced = 0, recordingsSynced = 0;

  if (Array.isArray(reports) && reports.length > 0) {
    const map = new Map<string, any>();
    for (const e of reports) {
      const phone = e?.businessNumber?.number || e?.businessNumber || 'unknown';
      const dateKey = (e.created || e.dateTimeUtc || new Date()).toString().split('T')[0];
      const key = `${phone}:${dateKey}`;
      const bucket = map.get(key) || { phone_number: phone, report_date: dateKey, calls_count: 0, answered_count: 0, missed_count: 0, total_duration: 0 };
      bucket.calls_count += 1;
      const st = String(e.state || e.callStatus || '').toLowerCase();
      if (st === 'connected' || st === 'connected') bucket.answered_count += 1;
      if (st === 'missed' || st === 'noanswer' || st === 'no_answer') bucket.missed_count += 1;
      if (e.duration) bucket.total_duration += Number(e.duration) || 0;
      map.set(key, bucket);
    }
    const rows = Array.from(map.values()).map((r:any)=>({ org_id: orgId, phone_number_id: null, report_type: 'calls', report_date: r.report_date, data: { calls_count: r.calls_count, answered_count: r.answered_count, missed_count: r.missed_count, total_duration: r.total_duration, phone_number: r.phone_number } }));
    if (rows.length > 0) {
      const { error } = await supabaseAdminClient.from('mightycall_reports').upsert(rows, { onConflict: 'org_id,report_date,report_type' });
      if (!error) reportsSynced = rows.length;
    }
  }

  if (Array.isArray(recordings) && recordings.length > 0) {
    const recRows = recordings.map((r:any)=>({ org_id: orgId, phone_number_id: null, call_id: r.callId || r.id, recording_url: r.recordingUrl, duration_seconds: r.duration, recording_date: r.date, metadata: r.metadata || r }));
    if (recRows.length > 0) {
      const { error } = await supabaseAdminClient.from('mightycall_recordings').upsert(recRows, { onConflict: 'org_id,call_id' });
      if (!error) recordingsSynced = recRows.length;
    }
  }

  return { reportsSynced, recordingsSynced };
}

export async function syncMightyCallRecordings(supabaseAdminClient: any, orgId: string, phoneNumberIds: string[], startDate: string, endDate: string, overrideCreds?: { clientId?: string; clientSecret?: string }) {
  const token = await getMightyCallAccessToken(overrideCreds);
  const recordings = await fetchMightyCallRecordings(token, phoneNumberIds, startDate, endDate);
  let recordingsSynced = 0;
  if (Array.isArray(recordings) && recordings.length > 0) {
    const recRows = recordings.map((r:any)=>({ org_id: orgId, phone_number_id: null, call_id: r.callId || r.id, recording_url: r.recordingUrl, duration_seconds: r.duration, recording_date: r.date, metadata: r.metadata || r }));
    const { error } = await supabaseAdminClient.from('mightycall_recordings').upsert(recRows, { onConflict: 'org_id,call_id' });
    if (!error) recordingsSynced = recRows.length;
  }
  return { recordingsSynced };
}

export async function syncMightyCallSMS(supabaseAdminClient: any, orgId: string, overrideCreds?: { clientId?: string; clientSecret?: string }) {
  const token = await getMightyCallAccessToken(overrideCreds);
  const list = await fetchMightyCallSMS(token);
  let smsSynced = 0;
  if (!Array.isArray(list) || list.length === 0) return { smsSynced };
  const rows = list.map((m:any)=>({ org_id: orgId, external_id: m.id ?? m.requestGuid ?? null, from_number: m.client?.address ?? m.from ?? null, to_number: m.businessNumber?.number ?? m.to ?? null, message_text: m.text ?? m.body ?? m.textModel?.text ?? null, status: m.status ?? 'received', sent_at: m.created ?? m.dateTimeUtc ?? new Date().toISOString(), metadata: m }));
  const { error } = await supabaseAdminClient.from('mightycall_sms_messages').upsert(rows, { onConflict: 'org_id,external_id' });
  if (!error) smsSynced = rows.length; else {
    const { error: fallback } = await supabaseAdminClient.from('sms_logs').upsert(rows.map(r=>({ org_id: r.org_id, from_number: r.from_number, to_numbers: r.to_number, message_text: r.message_text, direction: 'inbound', status: r.status, sent_at: r.sent_at, metadata: r.metadata })), { onConflict: 'org_id,from_number,sent_at' });
    if (!fallback) smsSynced = rows.length;
  }
  return { smsSynced };
}


    async function delay(ms: number) { return new Promise((r) => setTimeout(r, ms)); }
    async function requestWithRetry(url: string, opts: any, retries = 2, backoff = 250) {
      let attempt = 0;
      while (true) {
        attempt += 1;
        try {
          return await fetch(url, opts);
        } catch (e: any) {
          const msg = String(e?.message ?? e);
          if (attempt > retries) throw e;
          await delay(backoff * attempt);
        }
      }
    }

    function buildUrlVariants(base: string, endpoint: string) {
      const b = (base || '').replace(/\/$/, '');
      const ep = endpoint || '';
      return [`${b}${ep}`, `${b}/api${ep}`];
    }

    export async function getMightyCallAccessToken(): Promise<string> {
      const base = (MIGHTYCALL_BASE_URL || '').replace(/\/$/, '');
      const candidates = buildUrlVariants(base, '/auth/token');
      const clientId = MIGHTYCALL_API_KEY || '';
      const clientSecret = MIGHTYCALL_USER_KEY || '';

      for (const url of candidates) {
        try {
          const body = new URLSearchParams();
          body.append('grant_type', 'client_credentials');
          body.append('client_id', clientId);
          body.append('client_secret', clientSecret);
          const res = await requestWithRetry(url, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded', 'x-api-key': MIGHTYCALL_API_KEY || '' }, body: body.toString() }, 2, 300);
          const text = await res.text();
          if (!res.ok) continue;
          const j = JSON.parse(text || '{}');
          const token = j?.access_token || j?.token || null;
          if (token) return token;
        } catch (e) { continue; }
      }
      throw new Error('Unable to obtain MightyCall access token');
    }

    async function tryFetchJson(url: string, token?: string) {
      const res = await requestWithRetry(url, { method: 'GET', headers: { Accept: 'application/json', 'x-api-key': MIGHTYCALL_API_KEY || '', ...(token ? { Authorization: `Bearer ${token}` } : {}) } }, 2, 300);
      const text = await res.text().catch(() => '');
      if (!res.ok) return { ok: false, status: res.status, body: text };
      try { return { ok: true, status: res.status, body: JSON.parse(text || 'null') }; } catch (e) { return { ok: true, status: res.status, body: text }; }
    }

    export async function fetchMightyCallPhoneNumbers(token: string) {
      const base = (MIGHTYCALL_BASE_URL || '').replace(/\/$/, '');
      const endpoints = ['/phonenumbers', '/phone_numbers', '/v4/phonenumbers', '/v4/phone_numbers'];
      for (const ep of endpoints) {
        for (const url of buildUrlVariants(base, ep)) {
          const r = await tryFetchJson(url, token);
          if (r.ok && r.body) {
            const list = r.body?.data?.phoneNumbers ?? r.body?.phoneNumbers ?? r.body?.data ?? [];
            if (Array.isArray(list)) return list;
          }
        }
      }
      return [];
    }

    export async function fetchMightyCallCalls(token: string, params: Record<string,string> = {}) {
      const base = (MIGHTYCALL_BASE_URL || '').replace(/\/$/, '');
      const eps = ['/calls', '/api/calls', '/v4/calls', '/api/calls/list'];
      for (const ep of eps) {
        for (const url of buildUrlVariants(base, ep)) {
          const full = params && Object.keys(params).length ? `${url}?${new URLSearchParams(params).toString()}` : url;
          const r = await tryFetchJson(full, token);
          if (r.ok && r.body) {
            const list = r.body?.data?.calls ?? r.body?.calls ?? r.body ?? [];
            if (Array.isArray(list)) return list;
          }
        }
      }
      return [];
    }

    export async function fetchMightyCallJournalRequests(token: string, params: Record<string,string>) {
      const base = (MIGHTYCALL_BASE_URL || '').replace(/\/$/, '');
      const ep = '/journal/requests';
      for (const url of buildUrlVariants(base, ep)) {
        const full = `${url}?${new URLSearchParams(params).toString()}`;
        const r = await tryFetchJson(full, token);
        if (r.ok && r.body) {
          const list = r.body?.requests ?? r.body?.data?.requests ?? [];
          if (Array.isArray(list)) return list;
        }
      }
      return [];
    }

    export async function fetchMightyCallRecordings(token: string, startDate: string, endDate: string) {
      // Prefer calls endpoint which contains recordings, fallback to journal
      const calls = await fetchMightyCallCalls(token, { startUtc: startDate, endUtc: endDate, pageSize: '1000', skip: '0' });
      const recordings: any[] = [];
      for (const c of calls) {
        const rec = c?.callRecord ?? c?.recording ?? null;
        if (rec && (rec.uri || rec.fileName || rec.link)) {
          recordings.push({ id: c.id || c.callId, callId: c.id || c.callId, recordingUrl: rec.uri || rec.fileName || rec.link, duration: c.duration ?? null, date: c.dateTimeUtc ?? c.created ?? null, metadata: c });
        }
      }
      if (recordings.length > 0) return recordings;

      // journal fallback
      const jr = await fetchMightyCallJournalRequests(token, { from: `${startDate}T00:00:00Z`, to: `${endDate}T23:59:59Z`, type: 'Call', pageSize: '1000', page: '1' });
      for (const r of jr) {
        const link = r?.recording?.link ?? r?.recording?.uri ?? r?.textModel?.text ?? null;
        if (link) recordings.push({ id: r.id, callId: r.id, recordingUrl: link, duration: null, date: r.created ?? null, metadata: r });
      }
      return recordings;
    }

    export async function fetchMightyCallSMS(token?: string) {
      const t = token || await getMightyCallAccessToken();
      // try journal messages
      const list = await fetchMightyCallJournalRequests(t, { pageSize: '1000', page: '1', type: 'Message' });
      return Array.isArray(list) ? list : [];
    }

    // Sync helpers
    export async function syncMightyCallReports(supabaseAdminClient: any, orgId: string, phoneNumberIds: string[], startDate: string, endDate: string) {
      const token = await getMightyCallAccessToken();
      const journal = await fetchMightyCallJournalRequests(token, { from: `${startDate}T00:00:00Z`, to: `${endDate}T23:59:59Z`, type: 'Call', pageSize: '1000', page: '1' });
      const recordings = await fetchMightyCallRecordings(token, startDate, endDate);

      let reportsSynced = 0, recordingsSynced = 0;

      if (Array.isArray(journal) && journal.length > 0) {
        const reportMap = new Map<string, any>();
        for (const e of journal) {
          const phone = e?.businessNumber?.number || e?.businessNumber || 'unknown';
          const dateKey = (e.created || e.dateTimeUtc || new Date()).toString().split('T')[0];
          const key = `${phone}:${dateKey}`;
          const bucket = reportMap.get(key) || { phone_number: phone, report_date: dateKey, calls_count: 0, answered_count: 0, missed_count: 0, total_duration: 0 };
          bucket.calls_count += 1;
          const st = String(e.state || e.callStatus || '').toLowerCase();
          if (st === 'connected' || st === 'connected') bucket.answered_count += 1;
          if (st === 'missed' || st === 'noanswer' || st === 'no_answer') bucket.missed_count += 1;
          if (e.duration) bucket.total_duration += Number(e.duration) || 0;
          reportMap.set(key, bucket);
        }

        const rows = Array.from(reportMap.values()).map((r:any)=>({ org_id: orgId, phone_number_id: null, report_type: 'calls', report_date: r.report_date, data: { calls_count: r.calls_count, answered_count: r.answered_count, missed_count: r.missed_count, total_duration: r.total_duration, phone_number: r.phone_number } }));
        if (rows.length > 0) {
          const { error } = await supabaseAdminClient.from('mightycall_reports').upsert(rows, { onConflict: 'org_id,report_date,report_type' });
          if (!error) reportsSynced = rows.length;
        }
      }

      if (Array.isArray(recordings) && recordings.length > 0) {
        const recRows = recordings.map((r:any)=>({ org_id: orgId, phone_number_id: null, call_id: r.callId || r.id, recording_url: r.recordingUrl, duration_seconds: r.duration, recording_date: r.date, metadata: r.metadata || r }));
        if (recRows.length > 0) {
          const { error } = await supabaseAdminClient.from('mightycall_recordings').upsert(recRows, { onConflict: 'org_id,call_id' });
          if (!error) recordingsSynced = recRows.length;
        }
      }

      return { reportsSynced, recordingsSynced };
    }

    export async function syncMightyCallRecordings(supabaseAdminClient: any, orgId: string, phoneNumberIds: string[], startDate: string, endDate: string) {
      const token = await getMightyCallAccessToken();
      const recordings = await fetchMightyCallRecordings(token, startDate, endDate);
      let recordingsSynced = 0;
      if (Array.isArray(recordings) && recordings.length > 0) {
        const recRows = recordings.map((r:any)=>({ org_id: orgId, phone_number_id: null, call_id: r.callId || r.id, recording_url: r.recordingUrl, duration_seconds: r.duration, recording_date: r.date, metadata: r.metadata || r }));
        const { error } = await supabaseAdminClient.from('mightycall_recordings').upsert(recRows, { onConflict: 'org_id,call_id' });
        if (!error) recordingsSynced = recRows.length;
      }
      return { recordingsSynced };
    }

    export async function syncMightyCallSMS(supabaseAdminClient: any, orgId: string) {
      const token = await getMightyCallAccessToken();
      const list = await fetchMightyCallSMS(token);
      let smsSynced = 0;
      if (!Array.isArray(list) || list.length === 0) return { smsSynced };
      const rows = list.map((m:any)=>({ org_id: orgId, external_id: m.id ?? m.requestGuid ?? null, from_number: m.client?.address ?? m.from ?? null, to_number: m.businessNumber?.number ?? m.to ?? null, message_text: m.text ?? m.body ?? m.textModel?.text ?? null, status: m.status ?? 'received', sent_at: m.created ?? m.dateTimeUtc ?? new Date().toISOString(), metadata: m }));
      const { error } = await supabaseAdminClient.from('mightycall_sms_messages').upsert(rows, { onConflict: 'org_id,external_id' });
      if (!error) smsSynced = rows.length; else {
        const { error: fallback } = await supabaseAdminClient.from('sms_logs').upsert(rows.map(r=>({ org_id: r.org_id, from_number: r.from_number, to_numbers: r.to_number, message_text: r.message_text, direction: 'inbound', status: r.status, sent_at: r.sent_at, metadata: r.metadata })), { onConflict: 'org_id,from_number,sent_at' });
        if (!fallback) smsSynced = rows.length;
      }
      return { smsSynced };
    }

 */
export async function syncMightyCallCallHistory(supabaseAdminClient: any, orgId: string, filters?: any): Promise<{ callsSynced: number }> {
  const token = await getMightyCallAccessToken();
  const calls = await fetchMightyCallCalls(token, filters);

  let callsSynced = 0;

  // Always log fetched calls count so we can diagnose why zero rows are being synced
  try {
    console.log('[MightyCall sync] fetched calls count:', Array.isArray(calls) ? calls.length : 0);
    if (Array.isArray(calls) && calls.length > 0) {
      console.log('[MightyCall sync] calls sample:', JSON.stringify(calls.slice(0, 3), null, 2));
    }
  } catch (e) {
    console.warn('[MightyCall sync] failed to stringify calls sample', e);
  }

  if (calls.length > 0) {
    const callRows = calls.map((c: any) => ({
      org_id: orgId,
      from_number: c.from ?? c.from_number,
      to_number: c.to ?? c.to_number,
      status: c.status ?? c.callStatus,
      duration_seconds: c.duration ?? 0,
      started_at: c.dateTimeUtc ?? c.timestamp ?? new Date().toISOString(),
      ended_at: c.endedAt ?? c.ended_at ?? null,
      created_at: new Date().toISOString()
    }));

    const { error } = await supabaseAdminClient
      .from('calls')
      .insert(callRows)
      .select();

    if (!error) callsSynced = callRows.length;
    else console.warn('[MightyCall] call history insert error', error);
  }

  return { callsSynced };
}

/**
 * Sync SMS messages into the database.
 */
export async function syncSMSLog(supabaseAdminClient: any, orgId: string, message: any): Promise<{ smsSynced: boolean }> {
  try {
    const { error } = await supabaseAdminClient
      .from('sms_logs')
      .insert({
        org_id: orgId,
        from_number: message.from,
        to_numbers: message.to,
        message_text: message.text,
        direction: message.direction ?? 'outbound',
        status: message.status ?? 'sent',
        sent_at: new Date().toISOString(),
        metadata: message
      });

    if (error) {
      console.warn('[SMS Log] error', error);
      return { smsSynced: false };
    }
    return { smsSynced: true };
  } catch (err) {
    console.warn('[SMS Log] sync error', err);
    return { smsSynced: false };
  }
}

/**
 * Sync contacts into the database.
 */
export async function syncMightyCallContacts(supabaseAdminClient: any, orgId: string): Promise<{ contactsSynced: number }> {
  const token = await getMightyCallAccessToken();
  const contacts = await fetchMightyCallContacts(token);

  let contactsSynced = 0;

  if (contacts.length > 0) {
    const contactRows = contacts.map((c: any) => ({
      org_id: orgId,
      external_id: c.id ?? c.contactId,
      first_name: c.firstName ?? c.first_name ?? '',
      last_name: c.lastName ?? c.last_name ?? '',
      email: c.email ?? null,
      phone: c.phone ?? c.phoneNumber ?? null,
      company: c.company ?? null,
      metadata: c
    }));

    const { error } = await supabaseAdminClient
      .from('contact_events')
      .upsert(contactRows, { onConflict: 'org_id,external_id' });

    if (!error) contactsSynced = contactRows.length;
    else console.warn('[MightyCall] contacts sync error', error);
  }

  return { contactsSynced };
}

/**
 * Sync reports into the database.
 * Returns counts of inserted/updated records.
 */
export async function syncMightyCallReports(supabaseAdminClient: any, orgId: string, phoneNumberIds: string[], startDate: string, endDate: string, overrideCreds?: { clientId?: string; clientSecret?: string }): Promise<{ reportsSynced: number, recordingsSynced: number }> {
  const token = await getMightyCallAccessToken(overrideCreds);

  // Fetch reports and recordings
  const [reports, recordings] = await Promise.all([
    fetchMightyCallReports(token, phoneNumberIds, startDate, endDate),
    fetchMightyCallRecordings(token, phoneNumberIds, startDate, endDate)
  ]);

  let reportsSynced = 0;
  let recordingsSynced = 0;

  // Sync reports - journal entries are aggregated per day/phone
  if (reports.length > 0) {
    // Aggregate journal entries into daily reports
    const reportMap = new Map<string, any>();
    
    for (const entry of reports) {
      if (entry.type !== 'Call') continue;
      
      const businessNum = entry.businessNumber?.number || entry.to || 'unknown';
      const dateKey = new Date(entry.created || entry.dateTimeUtc || new Date()).toISOString().split('T')[0];
      const key = `${businessNum}:${dateKey}`;
      
      if (!reportMap.has(key)) {
        reportMap.set(key, {
          phone_number: businessNum,
          report_date: dateKey,
          calls_count: 0,
          answered_count: 0,
          missed_count: 0,
          total_duration: 0
        });
      }
      
      const report = reportMap.get(key)!;
      report.calls_count += 1;
      
      if (entry.state === 'Connected' || entry.state === 'connected') {
        report.answered_count += 1;
      } else if (entry.state === 'Missed' || entry.state === 'missed') {
        report.missed_count += 1;
      }
      
      if (entry.duration) {
        const duration = typeof entry.duration === 'string' ? parseInt(entry.duration, 10) : entry.duration;
        report.total_duration += isNaN(duration) ? 0 : duration;
      }
    }
    
    const reportRows = Array.from(reportMap.values()).map((r: any) => ({
      org_id: orgId,
      phone_number_id: null,
      report_type: 'calls',
      report_date: r.report_date,
      data: {
        calls_count: r.calls_count,
        answered_count: r.answered_count,
        missed_count: r.missed_count,
        answer_rate: r.calls_count > 0 ? (r.answered_count / r.calls_count) * 100 : 0,
        total_duration: r.total_duration,
        phone_number: r.phone_number
      }
    }));

    if (reportRows.length > 0) {
      const { error: reportError } = await supabaseAdminClient
        .from('mightycall_reports')
        .upsert(reportRows, { onConflict: 'org_id,report_date,report_type' });

      if (reportError) {
        console.warn('[MightyCall sync reports] error', reportError);
      } else {
        reportsSynced = reportRows.length;
      }
    }
  }

  // Sync recordings
  if (recordings.length > 0) {
    const recordingRows = recordings.map((r: any) => ({
      org_id: orgId,
      phone_number_id: null,
      call_id: r.callId || r.id,
      recording_url: r.recordingUrl,
      duration_seconds: r.duration,
      recording_date: r.date,
      metadata: r.metadata || {}
    }));

    const { error: recordingError } = await supabaseAdminClient
      .from('mightycall_recordings')
      .upsert(recordingRows, { onConflict: 'org_id,call_id' });

    if (recordingError) {
      console.warn('[MightyCall sync recordings] error', recordingError);
    } else {
      recordingsSynced = recordingRows.length;
    }
  }

  // Fallback: if upstream reports empty, synthesize from call history
  if ((reports.length === 0) ) {
    try {
      const calls = await fetchMightyCallCalls(token, { dateStart: startDate, dateEnd: endDate, limit: 5000 });
      if (Array.isArray(calls) && calls.length > 0) {
        // Load org phone numbers to map numbers->ids
        const { data: pnData, error: pnErr } = await supabaseAdminClient
          .from('phone_numbers')
          .select('id,number,number_digits')
          .eq('org_id', orgId);
        const phoneMapByDigits: Record<string, string> = {};
        const phoneMapByNumber: Record<string, string> = {};
        if (!pnErr && Array.isArray(pnData)) {
          for (const p of pnData) {
            if (p.number_digits) phoneMapByDigits[p.number_digits] = p.id;
            if (p.number) phoneMapByNumber[p.number] = p.id;
          }
        }

        // Aggregate per phone
        const agg: Record<string, any> = {};
        const recordingRows: any[] = [];
        for (const c of calls) {
          const toDigits = (c.to || c.to_number || '') .replace ? (c.to || c.to_number || '').replace(/\D/g,'') : String((c.to || c.to_number || '')).replace(/\D/g,'');
          const fromDigits = (c.from || c.from_number || '') .replace ? (c.from || c.from_number || '').replace(/\D/g,'') : String((c.from || c.from_number || '')).replace(/\D/g,'');
          const keyDigits = phoneMapByDigits[toDigits] ? toDigits : (phoneMapByDigits[fromDigits] ? fromDigits : (toDigits || fromDigits));
          const phoneId = phoneMapByDigits[keyDigits] || phoneMapByNumber[c.to] || phoneMapByNumber[c.from] || null;
          const aggKey = phoneId || keyDigits || 'unknown';
          if (!agg[aggKey]) agg[aggKey] = { calls_count:0, answered_count:0, missed_count:0, sum_handle:0, handle_count:0, sum_speed:0, speed_count:0 };
          const ent = agg[aggKey];
          ent.calls_count += 1;
          const st = String((c.status || c.callStatus || '')).toLowerCase();
          if (st === 'answered' || st === 'completed') {
            ent.answered_count += 1;
            const duration = (c.duration != null) ? Number(c.duration) : (c.ended_at && c.answered_at ? (new Date(c.ended_at).getTime()-new Date(c.answered_at).getTime())/1000 : 0);
            if (duration > 0) { ent.sum_handle += duration; ent.handle_count += 1; }
            if (c.answered_at && c.started_at) {
              const speed = (new Date(c.answered_at).getTime() - new Date(c.started_at).getTime())/1000;
              if (speed >= 0) { ent.sum_speed += speed; ent.speed_count += 1; }
            }
          } else if (st === 'missed') {
            ent.missed_count += 1;
          }

          // recording extraction
          const recordingUrl = c.recordingUrl || c.recording_url || c.recordingUrlRaw || null;
          if (recordingUrl) {
            recordingRows.push({ org_id: orgId, phone_number_id: phoneId, call_id: c.id || c.callId || null, recording_url: recordingUrl, duration_seconds: c.duration ?? null, recording_date: c.dateTimeUtc ?? c.timestamp ?? c.recording_date ?? null, metadata: c });
          }
        }

        // Upsert synthesized report rows
        const reportRows: any[] = [];
        for (const k of Object.keys(agg)) {
          const a = agg[k];
          const calls_count = a.calls_count;
          const answered_count = a.answered_count;
          const missed_count = a.missed_count;
          const answer_rate = calls_count === 0 ? 0 : Math.round((answered_count/calls_count) * 10000)/100;
          const avg_handle_seconds = a.handle_count > 0 ? Math.round(a.sum_handle / a.handle_count) : 0;
          const avg_speed_seconds = a.speed_count > 0 ? Math.round(a.sum_speed / a.speed_count) : 0;
          reportRows.push({ org_id: orgId, phone_number_id: pnData && pnData.find((p:any)=>p.id===k) ? k : null, report_type: 'calls', report_date: startDate, data: { calls_count, answered_count, missed_count, answer_rate, avg_handle_seconds, avg_speed_seconds } });
        }

        if (reportRows.length > 0) {
          const { error: rrErr } = await supabaseAdminClient.from('mightycall_reports').upsert(reportRows, { onConflict: 'org_id,phone_number_id,report_type,report_date' });
          if (rrErr) console.warn('[MightyCall synth reports] upsert error', rrErr);
          else reportsSynced += reportRows.length;
        }

        if (recordingRows.length > 0) {
          const { error: recErr } = await supabaseAdminClient.from('mightycall_recordings').upsert(recordingRows, { onConflict: 'org_id,call_id' });
          if (recErr) console.warn('[MightyCall synth recordings] upsert error', recErr);
          else recordingsSynced += recordingRows.length;
        }
      }
    } catch (e) {
      console.warn('[MightyCall synth fallback] failed:', e);
    }
  }

  return { reportsSynced, recordingsSynced };
}

/**
 * Sync only recordings into the database.
 * Returns counts of inserted/updated records.
 */
export async function syncMightyCallRecordings(supabaseAdminClient: any, orgId: string, phoneNumberIds: string[], startDate: string, endDate: string, overrideCreds?: { clientId?: string; clientSecret?: string }): Promise<{ recordingsSynced: number }> {
  const token = await getMightyCallAccessToken(overrideCreds);

  // Fetch recordings
  const recordings = await fetchMightyCallRecordings(token, phoneNumberIds, startDate, endDate);

  let recordingsSynced = 0;

  // Sync recordings
  if (recordings.length > 0) {
    const recordingRows = recordings.map((r: any) => ({
      org_id: orgId,
      phone_number_id: r.phoneNumberId,
      call_id: r.callId,
      recording_url: r.recordingUrl,
      duration_seconds: r.duration,
      recording_date: r.date,
      metadata: r.metadata || {}
    }));

    const { error: recordingError } = await supabaseAdminClient
      .from('mightycall_recordings')
      .upsert(recordingRows, { onConflict: 'org_id,call_id' });

    if (recordingError) {
      console.warn('[MightyCall sync recordings] error', recordingError);
    } else {
      recordingsSynced = recordingRows.length;
    }
  }

  return { recordingsSynced };
}
